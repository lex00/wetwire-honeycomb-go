// Command wetwire-honeycomb generates Honeycomb Query JSON from Go query declarations.
//
// Usage:
//
//	wetwire-honeycomb build ./queries/...   Generate Query JSON
//	wetwire-honeycomb lint ./queries/...    Check for issues
//	wetwire-honeycomb validate ./queries/...Validate queries
//	wetwire-honeycomb list ./queries/...    List discovered queries
//	wetwire-honeycomb graph ./queries/...   Generate dependency graph
//	wetwire-honeycomb init myqueries        Create new queries directory
//	wetwire-honeycomb import query.json     Import Query JSON to Go
//	wetwire-honeycomb design "prompt"       AI-assisted query design
//	wetwire-honeycomb test "prompt"         Run persona-based testing
//	wetwire-honeycomb diff old.json new.json Compare two query files
//	wetwire-honeycomb watch ./queries/...   Auto-rebuild on file changes
//	wetwire-honeycomb version               Show version
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"time"

	"github.com/lex00/wetwire-honeycomb-go/domain"
	"github.com/lex00/wetwire-honeycomb-go/internal/builder"
	"github.com/lex00/wetwire-honeycomb-go/internal/discovery"
	"github.com/lex00/wetwire-honeycomb-go/internal/serialize"
	"github.com/lex00/wetwire-honeycomb-go/query"
	"github.com/spf13/cobra"
)

func main() {
	// Use domain interface for auto-generated commands
	rootCmd := domain.CreateRootCommand(&domain.HoneycombDomain{})

	// Add domain-specific commands
	addDomainSpecificCommands(rootCmd)

	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

// addDomainSpecificCommands adds Honeycomb-specific commands to the root command.
func addDomainSpecificCommands(rootCmd *cobra.Command) {
	// Add custom commands not covered by domain interface
	rootCmd.AddCommand(
		newDiffCmd(),
		newWatchCmd(),
		newDesignCmd(),
		newTestCmd(),
		newMCPCmd(),
	)
}

// Removed: newVersionCmd - now auto-generated by domain interface
// Removed: newImportCmd - HoneycombDomain doesn't implement ImporterDomain

func newDiffCmd() *cobra.Command {
	var outputFile string
	var semantic bool
	var verbose bool

	cmd := &cobra.Command{
		Use:   "diff [packages]",
		Short: "Compare generated output vs existing config",
		Args:  cobra.MaximumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			if outputFile == "" {
				return fmt.Errorf("--output flag is required")
			}

			path := "."
			if len(args) > 0 {
				path = args[0]
			}

			// Build queries
			b, err := builder.NewBuilder(path)
			if err != nil {
				return fmt.Errorf("error: %w", err)
			}

			result, err := b.Build()
			if err != nil {
				return fmt.Errorf("build failed: %w", err)
			}

			if result.QueryCount() == 0 {
				return fmt.Errorf("no queries found")
			}

			// Generate current output
			queries := result.Queries()
			var currentJSON []byte

			if len(queries) == 1 {
				q := discoveredToQuery(queries[0])
				currentJSON, err = serialize.ToJSONPretty(q)
			} else {
				queryMap := make(map[string]json.RawMessage)
				for _, dq := range queries {
					q := discoveredToQuery(dq)
					data, e := serialize.ToJSON(q)
					if e != nil {
						err = e
						break
					}
					queryMap[dq.Name] = data
				}
				if err == nil {
					currentJSON, err = json.MarshalIndent(queryMap, "", "  ")
				}
			}

			if err != nil {
				return fmt.Errorf("serialization failed: %w", err)
			}

			// Read existing file
			existingJSON, err := os.ReadFile(outputFile)
			if err != nil {
				return fmt.Errorf("error reading %s: %w", outputFile, err)
			}

			// Compare
			if semantic {
				return semanticDiff(currentJSON, existingJSON, verbose)
			}
			return textDiff(currentJSON, existingJSON, outputFile, verbose)
		},
	}

	cmd.Flags().StringVar(&outputFile, "output", "", "JSON file to compare against")
	cmd.Flags().BoolVar(&semantic, "semantic", false, "Compare semantic structure instead of text")
	cmd.Flags().BoolVarP(&verbose, "verbose", "v", false, "Verbose output")

	return cmd
}

func newWatchCmd() *cobra.Command {
	var outputFile string
	var interval int
	var verbose bool

	cmd := &cobra.Command{
		Use:   "watch [packages]",
		Short: "Auto-rebuild on source file changes",
		Args:  cobra.MaximumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			path := "."
			if len(args) > 0 {
				path = args[0]
			}

			fmt.Printf("Watching %s for changes (interval: %ds)\n", path, interval)
			fmt.Println("Press Ctrl+C to stop")
			fmt.Println()

			var lastModTime time.Time
			var lastHash string

			for {
				// Get current modification state
				currentModTime, currentHash, err := getDirectoryState(path)
				if err != nil {
					fmt.Fprintf(os.Stderr, "Error checking files: %v\n", err)
					time.Sleep(time.Duration(interval) * time.Second)
					continue
				}

				// Check if anything changed
				if !currentModTime.Equal(lastModTime) || currentHash != lastHash {
					if lastModTime.IsZero() {
						fmt.Printf("[%s] Initial build\n", time.Now().Format("15:04:05"))
					} else {
						fmt.Printf("[%s] Changes detected, rebuilding...\n", time.Now().Format("15:04:05"))
					}

					// Build
					b, err := builder.NewBuilder(path)
					if err != nil {
						fmt.Fprintf(os.Stderr, "  Error: %v\n", err)
					} else {
						result, err := b.Build()
						if err != nil {
							fmt.Fprintf(os.Stderr, "  Build failed: %v\n", err)
						} else {
							if verbose {
								fmt.Printf("  Found %d queries\n", result.QueryCount())
							}

							if result.QueryCount() > 0 && outputFile != "" {
								// Write output
								queries := result.Queries()
								var jsonData []byte

								if len(queries) == 1 {
									q := discoveredToQuery(queries[0])
									jsonData, err = serialize.ToJSONPretty(q)
								} else {
									queryMap := make(map[string]json.RawMessage)
									for _, dq := range queries {
										q := discoveredToQuery(dq)
										data, e := serialize.ToJSON(q)
										if e != nil {
											err = e
											break
										}
										queryMap[dq.Name] = data
									}
									if err == nil {
										jsonData, err = json.MarshalIndent(queryMap, "", "  ")
									}
								}

								if err != nil {
									fmt.Fprintf(os.Stderr, "  Serialization failed: %v\n", err)
								} else {
									if err := os.WriteFile(outputFile, jsonData, 0644); err != nil {
										fmt.Fprintf(os.Stderr, "  Failed to write output: %v\n", err)
									} else {
										fmt.Printf("  Wrote %s (%d bytes)\n", outputFile, len(jsonData))
									}
								}
							} else if result.QueryCount() > 0 {
								fmt.Printf("  Build succeeded (%d queries)\n", result.QueryCount())
							} else {
								fmt.Println("  No queries found")
							}
						}
					}

					lastModTime = currentModTime
					lastHash = currentHash
				}

				time.Sleep(time.Duration(interval) * time.Second)
			}
		},
	}

	cmd.Flags().StringVar(&outputFile, "output", "", "Output file")
	cmd.Flags().IntVar(&interval, "interval", 2, "Polling interval in seconds")
	cmd.Flags().BoolVarP(&verbose, "verbose", "v", false, "Verbose output")

	return cmd
}

// Helper functions

// discoveredToQuery converts a DiscoveredQuery to a query.Query
func discoveredToQuery(dq discovery.DiscoveredQuery) query.Query {
	q := query.Query{
		Dataset: dq.Dataset,
		TimeRange: query.TimeRange{
			TimeRange: dq.TimeRange.TimeRange,
			StartTime: dq.TimeRange.StartTime,
			EndTime:   dq.TimeRange.EndTime,
		},
		Breakdowns: dq.Breakdowns,
		Limit:      dq.Limit,
	}

	for _, c := range dq.Calculations {
		q.Calculations = append(q.Calculations, query.Calculation{
			Op:     c.Op,
			Column: c.Column,
		})
	}

	for _, f := range dq.Filters {
		q.Filters = append(q.Filters, query.Filter{
			Column: f.Column,
			Op:     f.Op,
			Value:  f.Value,
		})
	}

	return q
}

// Removed: discoveredToBoard, discoveredToSLO, discoveredToTrigger - moved to domain package

// Removed: generateGoCode and formatValue - only used by removed import command

func textDiff(current, existing []byte, filename string, verbose bool) error {
	// Normalize line endings
	current = bytes.ReplaceAll(current, []byte("\r\n"), []byte("\n"))
	existing = bytes.ReplaceAll(existing, []byte("\r\n"), []byte("\n"))

	if bytes.Equal(current, existing) {
		if verbose {
			fmt.Println("Files are identical")
		}
		return nil
	}

	// Show line-by-line diff
	currentLines := strings.Split(string(current), "\n")
	existingLines := strings.Split(string(existing), "\n")

	fmt.Printf("--- %s (existing)\n", filename)
	fmt.Println("+++ generated")

	maxLen := len(currentLines)
	if len(existingLines) > maxLen {
		maxLen = len(existingLines)
	}

	for i := 0; i < maxLen; i++ {
		var currLine, existLine string
		if i < len(currentLines) {
			currLine = currentLines[i]
		}
		if i < len(existingLines) {
			existLine = existingLines[i]
		}

		if currLine != existLine {
			if existLine != "" {
				fmt.Printf("-%s\n", existLine)
			}
			if currLine != "" {
				fmt.Printf("+%s\n", currLine)
			}
		}
	}

	return fmt.Errorf("files differ")
}

func semanticDiff(current, existing []byte, verbose bool) error {
	var currData, existData interface{}

	if err := json.Unmarshal(current, &currData); err != nil {
		return fmt.Errorf("error parsing generated JSON: %w", err)
	}

	if err := json.Unmarshal(existing, &existData); err != nil {
		return fmt.Errorf("error parsing existing JSON: %w", err)
	}

	if reflect.DeepEqual(currData, existData) {
		if verbose {
			fmt.Println("Semantically identical")
		}
		return nil
	}

	// Show structural differences
	diffs := compareJSON(currData, existData, "")
	for _, d := range diffs {
		fmt.Println(d)
	}

	return fmt.Errorf("semantic differences found")
}

func compareJSON(a, b interface{}, path string) []string {
	var diffs []string

	switch aTyped := a.(type) {
	case map[string]interface{}:
		bTyped, ok := b.(map[string]interface{})
		if !ok {
			return []string{fmt.Sprintf("Type mismatch at %s: map vs %T", path, b)}
		}

		// Check keys in a
		for k, av := range aTyped {
			newPath := path + "." + k
			if path == "" {
				newPath = k
			}
			if bv, ok := bTyped[k]; ok {
				diffs = append(diffs, compareJSON(av, bv, newPath)...)
			} else {
				diffs = append(diffs, fmt.Sprintf("Key missing in existing: %s", newPath))
			}
		}

		// Check keys in b not in a
		for k := range bTyped {
			newPath := path + "." + k
			if path == "" {
				newPath = k
			}
			if _, ok := aTyped[k]; !ok {
				diffs = append(diffs, fmt.Sprintf("Extra key in existing: %s", newPath))
			}
		}

	case []interface{}:
		bTyped, ok := b.([]interface{})
		if !ok {
			return []string{fmt.Sprintf("Type mismatch at %s: array vs %T", path, b)}
		}

		if len(aTyped) != len(bTyped) {
			diffs = append(diffs, fmt.Sprintf("Array length mismatch at %s: %d vs %d", path, len(aTyped), len(bTyped)))
		}

		minLen := len(aTyped)
		if len(bTyped) < minLen {
			minLen = len(bTyped)
		}

		for i := 0; i < minLen; i++ {
			diffs = append(diffs, compareJSON(aTyped[i], bTyped[i], fmt.Sprintf("%s[%d]", path, i))...)
		}

	default:
		if !reflect.DeepEqual(a, b) {
			diffs = append(diffs, fmt.Sprintf("Value mismatch at %s: %v vs %v", path, a, b))
		}
	}

	return diffs
}

func getDirectoryState(dir string) (time.Time, string, error) {
	var latestTime time.Time
	var fileList []string

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip hidden directories and non-Go files
		if info.IsDir() {
			if strings.HasPrefix(info.Name(), ".") {
				return filepath.SkipDir
			}
			return nil
		}

		if !strings.HasSuffix(info.Name(), ".go") {
			return nil
		}

		if info.ModTime().After(latestTime) {
			latestTime = info.ModTime()
		}

		fileList = append(fileList, fmt.Sprintf("%s:%d", path, info.ModTime().UnixNano()))
		return nil
	})

	if err != nil {
		return latestTime, "", err
	}

	// Create a simple hash of file states
	hash := strings.Join(fileList, "|")
	return latestTime, hash, nil
}
