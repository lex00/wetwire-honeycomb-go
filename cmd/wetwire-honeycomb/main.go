// Command wetwire-honeycomb generates Honeycomb Query JSON from Go query declarations.
//
// Usage:
//
//	wetwire-honeycomb build ./queries/...   Generate Query JSON
//	wetwire-honeycomb lint ./queries/...    Check for issues
//	wetwire-honeycomb validate ./queries/...Validate queries
//	wetwire-honeycomb list ./queries/...    List discovered queries
//	wetwire-honeycomb graph ./queries/...   Generate dependency graph
//	wetwire-honeycomb init myqueries        Create new queries directory
//	wetwire-honeycomb import query.json     Import Query JSON to Go
//	wetwire-honeycomb design "prompt"       AI-assisted query design
//	wetwire-honeycomb test "prompt"         Run persona-based testing
//	wetwire-honeycomb diff old.json new.json Compare two query files
//	wetwire-honeycomb watch ./queries/...   Auto-rebuild on file changes
//	wetwire-honeycomb version               Show version
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"time"

	"github.com/lex00/wetwire-honeycomb-go/board"
	"github.com/lex00/wetwire-honeycomb-go/domain"
	"github.com/lex00/wetwire-honeycomb-go/internal/builder"
	"github.com/lex00/wetwire-honeycomb-go/internal/discovery"
	"github.com/lex00/wetwire-honeycomb-go/internal/serialize"
	"github.com/lex00/wetwire-honeycomb-go/query"
	"github.com/lex00/wetwire-honeycomb-go/slo"
	"github.com/lex00/wetwire-honeycomb-go/trigger"
	"github.com/spf13/cobra"
)

func main() {
	// Use domain interface for auto-generated commands
	rootCmd := domain.CreateRootCommand(&domain.HoneycombDomain{})

	// Add domain-specific commands
	addDomainSpecificCommands(rootCmd)

	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

// addDomainSpecificCommands adds Honeycomb-specific commands to the root command.
func addDomainSpecificCommands(rootCmd *cobra.Command) {
	// Add custom commands not covered by domain interface
	rootCmd.AddCommand(
		newImportCmd(),
		newDiffCmd(),
		newWatchCmd(),
		newDesignCmd(),
		newTestCmd(),
		newMCPCmd(),
	)
}

// Removed: newVersionCmd - now auto-generated by domain interface

func newImportCmd() *cobra.Command {
	var output string
	var pkg string
	var name string

	cmd := &cobra.Command{
		Use:   "import <file.json>",
		Short: "Convert Query JSON to Go code",
		Args:  cobra.ExactArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			inputFile := args[0]

			// Read JSON file
			data, err := os.ReadFile(inputFile)
			if err != nil {
				return fmt.Errorf("error reading file: %w", err)
			}

			// Parse JSON
			var raw map[string]any
			if err := json.Unmarshal(data, &raw); err != nil {
				return fmt.Errorf("error parsing JSON: %w", err)
			}

			// Generate Go code
			goCode := generateGoCode(pkg, name, raw)

			// Output
			if output == "" {
				fmt.Print(goCode)
			} else {
				if err := os.WriteFile(output, []byte(goCode), 0644); err != nil {
					return fmt.Errorf("error writing file: %w", err)
				}
			}

			return nil
		},
	}

	cmd.Flags().StringVarP(&output, "output", "o", "", "Output file (default: stdout)")
	cmd.Flags().StringVarP(&pkg, "package", "p", "queries", "Package name for generated code")
	cmd.Flags().StringVarP(&name, "name", "n", "Query", "Variable name for the query")

	return cmd
}

func newDiffCmd() *cobra.Command {
	var outputFile string
	var semantic bool
	var verbose bool

	cmd := &cobra.Command{
		Use:   "diff [packages]",
		Short: "Compare generated output vs existing config",
		Args:  cobra.MaximumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			if outputFile == "" {
				return fmt.Errorf("--output flag is required")
			}

			path := "."
			if len(args) > 0 {
				path = args[0]
			}

			// Build queries
			b, err := builder.NewBuilder(path)
			if err != nil {
				return fmt.Errorf("error: %w", err)
			}

			result, err := b.Build()
			if err != nil {
				return fmt.Errorf("build failed: %w", err)
			}

			if result.QueryCount() == 0 {
				return fmt.Errorf("no queries found")
			}

			// Generate current output
			queries := result.Queries()
			var currentJSON []byte

			if len(queries) == 1 {
				q := discoveredToQuery(queries[0])
				currentJSON, err = serialize.ToJSONPretty(q)
			} else {
				queryMap := make(map[string]json.RawMessage)
				for _, dq := range queries {
					q := discoveredToQuery(dq)
					data, e := serialize.ToJSON(q)
					if e != nil {
						err = e
						break
					}
					queryMap[dq.Name] = data
				}
				if err == nil {
					currentJSON, err = json.MarshalIndent(queryMap, "", "  ")
				}
			}

			if err != nil {
				return fmt.Errorf("serialization failed: %w", err)
			}

			// Read existing file
			existingJSON, err := os.ReadFile(outputFile)
			if err != nil {
				return fmt.Errorf("error reading %s: %w", outputFile, err)
			}

			// Compare
			if semantic {
				return semanticDiff(currentJSON, existingJSON, verbose)
			}
			return textDiff(currentJSON, existingJSON, outputFile, verbose)
		},
	}

	cmd.Flags().StringVar(&outputFile, "output", "", "JSON file to compare against")
	cmd.Flags().BoolVar(&semantic, "semantic", false, "Compare semantic structure instead of text")
	cmd.Flags().BoolVarP(&verbose, "verbose", "v", false, "Verbose output")

	return cmd
}

func newWatchCmd() *cobra.Command {
	var outputFile string
	var interval int
	var verbose bool

	cmd := &cobra.Command{
		Use:   "watch [packages]",
		Short: "Auto-rebuild on source file changes",
		Args:  cobra.MaximumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			path := "."
			if len(args) > 0 {
				path = args[0]
			}

			fmt.Printf("Watching %s for changes (interval: %ds)\n", path, interval)
			fmt.Println("Press Ctrl+C to stop")
			fmt.Println()

			var lastModTime time.Time
			var lastHash string

			for {
				// Get current modification state
				currentModTime, currentHash, err := getDirectoryState(path)
				if err != nil {
					fmt.Fprintf(os.Stderr, "Error checking files: %v\n", err)
					time.Sleep(time.Duration(interval) * time.Second)
					continue
				}

				// Check if anything changed
				if !currentModTime.Equal(lastModTime) || currentHash != lastHash {
					if lastModTime.IsZero() {
						fmt.Printf("[%s] Initial build\n", time.Now().Format("15:04:05"))
					} else {
						fmt.Printf("[%s] Changes detected, rebuilding...\n", time.Now().Format("15:04:05"))
					}

					// Build
					b, err := builder.NewBuilder(path)
					if err != nil {
						fmt.Fprintf(os.Stderr, "  Error: %v\n", err)
					} else {
						result, err := b.Build()
						if err != nil {
							fmt.Fprintf(os.Stderr, "  Build failed: %v\n", err)
						} else {
							if verbose {
								fmt.Printf("  Found %d queries\n", result.QueryCount())
							}

							if result.QueryCount() > 0 && outputFile != "" {
								// Write output
								queries := result.Queries()
								var jsonData []byte

								if len(queries) == 1 {
									q := discoveredToQuery(queries[0])
									jsonData, err = serialize.ToJSONPretty(q)
								} else {
									queryMap := make(map[string]json.RawMessage)
									for _, dq := range queries {
										q := discoveredToQuery(dq)
										data, e := serialize.ToJSON(q)
										if e != nil {
											err = e
											break
										}
										queryMap[dq.Name] = data
									}
									if err == nil {
										jsonData, err = json.MarshalIndent(queryMap, "", "  ")
									}
								}

								if err != nil {
									fmt.Fprintf(os.Stderr, "  Serialization failed: %v\n", err)
								} else {
									if err := os.WriteFile(outputFile, jsonData, 0644); err != nil {
										fmt.Fprintf(os.Stderr, "  Failed to write output: %v\n", err)
									} else {
										fmt.Printf("  Wrote %s (%d bytes)\n", outputFile, len(jsonData))
									}
								}
							} else if result.QueryCount() > 0 {
								fmt.Printf("  Build succeeded (%d queries)\n", result.QueryCount())
							} else {
								fmt.Println("  No queries found")
							}
						}
					}

					lastModTime = currentModTime
					lastHash = currentHash
				}

				time.Sleep(time.Duration(interval) * time.Second)
			}
		},
	}

	cmd.Flags().StringVar(&outputFile, "output", "", "Output file")
	cmd.Flags().IntVar(&interval, "interval", 2, "Polling interval in seconds")
	cmd.Flags().BoolVarP(&verbose, "verbose", "v", false, "Verbose output")

	return cmd
}

// Helper functions

// discoveredToQuery converts a DiscoveredQuery to a query.Query
func discoveredToQuery(dq discovery.DiscoveredQuery) query.Query {
	q := query.Query{
		Dataset: dq.Dataset,
		TimeRange: query.TimeRange{
			TimeRange: dq.TimeRange.TimeRange,
			StartTime: dq.TimeRange.StartTime,
			EndTime:   dq.TimeRange.EndTime,
		},
		Breakdowns: dq.Breakdowns,
		Limit:      dq.Limit,
	}

	for _, c := range dq.Calculations {
		q.Calculations = append(q.Calculations, query.Calculation{
			Op:     c.Op,
			Column: c.Column,
		})
	}

	for _, f := range dq.Filters {
		q.Filters = append(q.Filters, query.Filter{
			Column: f.Column,
			Op:     f.Op,
			Value:  f.Value,
		})
	}

	return q
}

// discoveredToBoard converts a DiscoveredBoard to a board.Board
func discoveredToBoard(db discovery.DiscoveredBoard) board.Board {
	return board.Board{
		Name:        db.BoardName,
		Description: db.Description,
		// Panels are not preserved in discovery - would need AST re-evaluation
		// This provides basic metadata for serialization
	}
}

// discoveredToSLO converts a DiscoveredSLO to an slo.SLO
func discoveredToSLO(ds discovery.DiscoveredSLO) slo.SLO {
	return slo.SLO{
		Name:        ds.SLOName,
		Description: ds.Description,
		Dataset:     ds.Dataset,
		Target:      slo.Percentage(ds.TargetPercentage),
		TimePeriod:  slo.Days(ds.TimePeriodDays),
		// SLI and BurnAlerts would need AST re-evaluation
	}
}

// discoveredToTrigger converts a DiscoveredTrigger to a trigger.Trigger
func discoveredToTrigger(dt discovery.DiscoveredTrigger) trigger.Trigger {
	return trigger.Trigger{
		Name:        dt.TriggerName,
		Description: dt.Description,
		Dataset:     dt.Dataset,
		Frequency:   trigger.Seconds(dt.FrequencySeconds),
		Disabled:    dt.Disabled,
		// Query and Recipients would need AST re-evaluation
	}
}

// generateGoCode generates Go code from a parsed query JSON
func generateGoCode(pkg, name string, raw map[string]any) string {
	var code string
	code += fmt.Sprintf("package %s\n\n", pkg)
	code += "import \"github.com/lex00/wetwire-honeycomb-go/query\"\n\n"
	code += fmt.Sprintf("var %s = query.Query{\n", name)

	// Time range
	if tr, ok := raw["time_range"].(float64); ok {
		hours := int(tr) / 3600
		if hours*3600 == int(tr) {
			code += fmt.Sprintf("\tTimeRange: query.Hours(%d),\n", hours)
		} else {
			code += fmt.Sprintf("\tTimeRange: query.Seconds(%d),\n", int(tr))
		}
	}

	// Breakdowns
	if breakdowns, ok := raw["breakdowns"].([]any); ok && len(breakdowns) > 0 {
		code += "\tBreakdowns: []string{"
		for i, b := range breakdowns {
			if i > 0 {
				code += ", "
			}
			code += fmt.Sprintf("%q", b)
		}
		code += "},\n"
	}

	// Calculations
	if calcs, ok := raw["calculations"].([]any); ok && len(calcs) > 0 {
		code += "\tCalculations: []query.Calculation{\n"
		for _, c := range calcs {
			cm := c.(map[string]any)
			op := cm["op"].(string)
			col, hasCol := cm["column"].(string)

			if op == "COUNT" && !hasCol {
				code += "\t\tquery.Count(),\n"
			} else if hasCol {
				switch op {
				case "P99":
					code += fmt.Sprintf("\t\tquery.P99(%q),\n", col)
				case "P95":
					code += fmt.Sprintf("\t\tquery.P95(%q),\n", col)
				case "P90":
					code += fmt.Sprintf("\t\tquery.P90(%q),\n", col)
				case "P75":
					code += fmt.Sprintf("\t\tquery.P75(%q),\n", col)
				case "P50":
					code += fmt.Sprintf("\t\tquery.P50(%q),\n", col)
				case "AVG":
					code += fmt.Sprintf("\t\tquery.Avg(%q),\n", col)
				case "SUM":
					code += fmt.Sprintf("\t\tquery.Sum(%q),\n", col)
				case "MIN":
					code += fmt.Sprintf("\t\tquery.Min(%q),\n", col)
				case "MAX":
					code += fmt.Sprintf("\t\tquery.Max(%q),\n", col)
				case "COUNT":
					code += fmt.Sprintf("\t\tquery.CountDistinct(%q),\n", col)
				default:
					code += fmt.Sprintf("\t\t{Op: %q, Column: %q},\n", op, col)
				}
			}
		}
		code += "\t},\n"
	}

	// Filters
	if filters, ok := raw["filters"].([]any); ok && len(filters) > 0 {
		code += "\tFilters: []query.Filter{\n"
		for _, f := range filters {
			fm := f.(map[string]any)
			col := fm["column"].(string)
			op := fm["op"].(string)
			val := fm["value"]

			switch op {
			case "=":
				code += fmt.Sprintf("\t\tquery.Equals(%q, %v),\n", col, formatValue(val))
			case "!=":
				code += fmt.Sprintf("\t\tquery.NotEquals(%q, %v),\n", col, formatValue(val))
			case ">":
				code += fmt.Sprintf("\t\tquery.GT(%q, %v),\n", col, formatValue(val))
			case ">=":
				code += fmt.Sprintf("\t\tquery.GTE(%q, %v),\n", col, formatValue(val))
			case "<":
				code += fmt.Sprintf("\t\tquery.LT(%q, %v),\n", col, formatValue(val))
			case "<=":
				code += fmt.Sprintf("\t\tquery.LTE(%q, %v),\n", col, formatValue(val))
			default:
				code += fmt.Sprintf("\t\t{Column: %q, Op: %q, Value: %v},\n", col, op, formatValue(val))
			}
		}
		code += "\t},\n"
	}

	// Limit
	if limit, ok := raw["limit"].(float64); ok && limit > 0 {
		code += fmt.Sprintf("\tLimit: %d,\n", int(limit))
	}

	code += "}\n"
	return code
}

func formatValue(v any) string {
	switch val := v.(type) {
	case string:
		return fmt.Sprintf("%q", val)
	case float64:
		if val == float64(int(val)) {
			return fmt.Sprintf("%d", int(val))
		}
		return fmt.Sprintf("%v", val)
	default:
		return fmt.Sprintf("%v", val)
	}
}

func textDiff(current, existing []byte, filename string, verbose bool) error {
	// Normalize line endings
	current = bytes.ReplaceAll(current, []byte("\r\n"), []byte("\n"))
	existing = bytes.ReplaceAll(existing, []byte("\r\n"), []byte("\n"))

	if bytes.Equal(current, existing) {
		if verbose {
			fmt.Println("Files are identical")
		}
		return nil
	}

	// Show line-by-line diff
	currentLines := strings.Split(string(current), "\n")
	existingLines := strings.Split(string(existing), "\n")

	fmt.Printf("--- %s (existing)\n", filename)
	fmt.Println("+++ generated")

	maxLen := len(currentLines)
	if len(existingLines) > maxLen {
		maxLen = len(existingLines)
	}

	for i := 0; i < maxLen; i++ {
		var currLine, existLine string
		if i < len(currentLines) {
			currLine = currentLines[i]
		}
		if i < len(existingLines) {
			existLine = existingLines[i]
		}

		if currLine != existLine {
			if existLine != "" {
				fmt.Printf("-%s\n", existLine)
			}
			if currLine != "" {
				fmt.Printf("+%s\n", currLine)
			}
		}
	}

	return fmt.Errorf("files differ")
}

func semanticDiff(current, existing []byte, verbose bool) error {
	var currData, existData interface{}

	if err := json.Unmarshal(current, &currData); err != nil {
		return fmt.Errorf("error parsing generated JSON: %w", err)
	}

	if err := json.Unmarshal(existing, &existData); err != nil {
		return fmt.Errorf("error parsing existing JSON: %w", err)
	}

	if reflect.DeepEqual(currData, existData) {
		if verbose {
			fmt.Println("Semantically identical")
		}
		return nil
	}

	// Show structural differences
	diffs := compareJSON(currData, existData, "")
	for _, d := range diffs {
		fmt.Println(d)
	}

	return fmt.Errorf("semantic differences found")
}

func compareJSON(a, b interface{}, path string) []string {
	var diffs []string

	switch aTyped := a.(type) {
	case map[string]interface{}:
		bTyped, ok := b.(map[string]interface{})
		if !ok {
			return []string{fmt.Sprintf("Type mismatch at %s: map vs %T", path, b)}
		}

		// Check keys in a
		for k, av := range aTyped {
			newPath := path + "." + k
			if path == "" {
				newPath = k
			}
			if bv, ok := bTyped[k]; ok {
				diffs = append(diffs, compareJSON(av, bv, newPath)...)
			} else {
				diffs = append(diffs, fmt.Sprintf("Key missing in existing: %s", newPath))
			}
		}

		// Check keys in b not in a
		for k := range bTyped {
			newPath := path + "." + k
			if path == "" {
				newPath = k
			}
			if _, ok := aTyped[k]; !ok {
				diffs = append(diffs, fmt.Sprintf("Extra key in existing: %s", newPath))
			}
		}

	case []interface{}:
		bTyped, ok := b.([]interface{})
		if !ok {
			return []string{fmt.Sprintf("Type mismatch at %s: array vs %T", path, b)}
		}

		if len(aTyped) != len(bTyped) {
			diffs = append(diffs, fmt.Sprintf("Array length mismatch at %s: %d vs %d", path, len(aTyped), len(bTyped)))
		}

		minLen := len(aTyped)
		if len(bTyped) < minLen {
			minLen = len(bTyped)
		}

		for i := 0; i < minLen; i++ {
			diffs = append(diffs, compareJSON(aTyped[i], bTyped[i], fmt.Sprintf("%s[%d]", path, i))...)
		}

	default:
		if !reflect.DeepEqual(a, b) {
			diffs = append(diffs, fmt.Sprintf("Value mismatch at %s: %v vs %v", path, a, b))
		}
	}

	return diffs
}

func getDirectoryState(dir string) (time.Time, string, error) {
	var latestTime time.Time
	var fileList []string

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip hidden directories and non-Go files
		if info.IsDir() {
			if strings.HasPrefix(info.Name(), ".") {
				return filepath.SkipDir
			}
			return nil
		}

		if !strings.HasSuffix(info.Name(), ".go") {
			return nil
		}

		if info.ModTime().After(latestTime) {
			latestTime = info.ModTime()
		}

		fileList = append(fileList, fmt.Sprintf("%s:%d", path, info.ModTime().UnixNano()))
		return nil
	})

	if err != nil {
		return latestTime, "", err
	}

	// Create a simple hash of file states
	hash := strings.Join(fileList, "|")
	return latestTime, hash, nil
}
