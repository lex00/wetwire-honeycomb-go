# E-commerce Checkout Flow Observability

Create a comprehensive observability setup for an e-commerce checkout flow using wetwire-honeycomb-go. This scenario demonstrates the complete Query→SLO→Trigger→Board chain for monitoring a critical user journey.

## Service Configuration

```yaml
checkout_flow:
  dataset: otel-demo
  services:
    - checkoutservice
    - cartservice
    - paymentservice
    - frauddetectionservice
  slo_targets:
    availability: 99.9%
    latency_p95: 2000ms
    payment_success: 99.95%
```

## Requirements

### 1. Queries (4 total)

Create these queries in `queries.go`:

**CheckoutFlowLatency** - Track end-to-end checkout latency across all services
- Dataset: otel-demo
- TimeRange: 1 hour
- Breakdowns: service.name, http.route
- Calculations: P99, P95, P50, Average duration_ms
- Filters: service.name in [checkoutservice, cartservice, paymentservice, frauddetectionservice]

**PaymentFraudCorrelation** - Correlate payment attempts with fraud detection results
- Dataset: otel-demo
- TimeRange: 24 hours
- Breakdowns: fraud.detected, payment.status, payment.method
- Calculations: Count, Avg(fraud.score)
- Filters: trace.parent_id exists (to ensure we have trace context)

**ErrorRateByService** - Track error rates across checkout services
- Dataset: otel-demo
- TimeRange: 2 hours
- Breakdowns: service.name, error.type
- Calculations: Count
- Filters: error exists, service.name in checkout services

**CheckoutFunnelAnalysis** - Track user progression through checkout funnel
- Dataset: otel-demo
- TimeRange: 6 hours
- Breakdowns: checkout.step
- Calculations: Count, Heatmap(duration_ms)
- Filters: http.route contains "/checkout"

### 2. SLOs (3 total)

Create these SLOs in `slos.go`:

**CheckoutAvailability** - 99.9% of checkout requests succeed
- Time Period: 30 days
- Target: 99.9%
- Use ratio-based SLO with success/total queries

**CheckoutLatency** - 95% of checkouts complete under 2000ms
- Time Period: 30 days
- Target: 95%
- Threshold: 2000ms on duration_ms

**PaymentSuccess** - 99.95% of payment attempts succeed
- Time Period: 30 days
- Target: 99.95%
- Filter on payment service specifically

### 3. Triggers (2 total)

Create these triggers in `triggers.go`:

**HighLatencyAlert** - Alert when P95 latency exceeds 3000ms
- Frequency: Every 5 minutes
- Threshold: P95 > 3000ms
- References: CheckoutFlowLatency query

**ErrorRateSpike** - Alert when error rate exceeds 5%
- Frequency: Every 3 minutes
- Threshold: Error count > 100 in window
- References: ErrorRateByService query

### 4. Board (1 dashboard with 4 panels)

Create this board in `boards.go`:

**CheckoutMonitoring** - Comprehensive checkout flow dashboard
- Panel 1: CheckoutFlowLatency query visualization (line graph)
- Panel 2: CheckoutAvailability SLO status (SLO panel)
- Panel 3: ErrorRateByService query visualization (bar chart)
- Panel 4: CheckoutFunnelAnalysis query visualization (heatmap)

## Implementation Notes

- Package name should be `ecommerce_scenario`
- Import path: `github.com/lex00/wetwire-honeycomb-go/query`
- All queries, SLOs, triggers, and boards should be top-level var declarations
- Use typed calculation functions (query.P99, query.Count, etc.)
- Use typed filter functions (query.GT, query.Contains, query.Exists, etc.)
- Use typed time range functions (query.Hours, query.Days, etc.)
- Follow the patterns shown in examples/full_stack/

## File Structure

```
examples/ecommerce_scenario/
├── queries.go    # All 4 queries
├── slos.go       # All 3 SLOs
├── triggers.go   # All 2 triggers
└── boards.go     # 1 board with 4 panels
```

## Expected Output

This scenario should generate valid Honeycomb Query JSON for all components that can be used with the Honeycomb API to:
- Monitor checkout flow performance
- Track SLO compliance
- Alert on anomalies
- Visualize the complete checkout journey

The code should compile cleanly and pass all lint rules (WHC001-WHC005).
